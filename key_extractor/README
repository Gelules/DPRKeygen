DPRKeygen: The Red Star OS 3 Server Keygen (not really, not yet).

Usage:
    ./key_extractor.sh PID_OF_THE_VIRTUAL_MACHINE_AFTER_VALIDATING_AT_LEAST_ONCE_A_BLANK_LICENSE_KEY

Warning:
    You may need to add
    set auto-load safe-path /
    to /root/.config/gdb/gdbinit or $HOME/.config/gdb/gdbinit
    because of GDB reasons.

How does it work:
    It extracts the memory from a virtual machine (tested on QEMU/KVM and
    nothing else for now), searches for a specific pattern and prints the
    license key. You must first validate a blank license key on the screen menu
    asking for the license key.

How to make it work:
    Boot a Red Star OS 3 Server on a virtual machine (preferably QEMU/KVM for
    now). When the launcher ask you to put the license key, just directly go for
    the Validation button, with a blank input. This makes Red Star OS 3 Server
    generates the real license key in its memory.

    Then execute with root permissions the script with the PID of the virtual
    machine as a paramater. Wait for some time (1 to 3 minutes depending on your
    computer, on mine it takes just above a minute), then the key appears.

    The script does not check the PID, so whatever you send in, it will do its
    business without any verification. Please provide the correct PID.

Why?:
    Read the other text file which was provided with the ISO. Originally, you
    had to put first a boot.iso file and then hot swap with the real iso file to
    bypass the license key. slipstream then ask if someone would try to make a
    keygen out of it. I searched for the keygen on Internet but apparently, no
    one has ever been published. Now, it *almost* is.

Technically:
    I made everything with Binary Ninja.

    The interesting binary is located in ./isolinux/initrd.img{/sbin/loader}.
    I first reversed it to automatically bypass the screen asking for the
    license. But where is the fun in that?
    The code you're looking for if you want to try is located at 0x080539f7. It
    is a strcmp between your input and the actual key.

    The funny part is: the keygen is already included. It generates a license
    key from the machine id. So, exporting the code would be simple enough,
    right?

    Now comes the interesting part, how all of this is actually working.
    0x0805214b is the generation of the variable that I call "machind_id",
    generated by the "machine_id_gen" function (0x0804d890). It uses some
    system for networking functions for the generation and concatenate it to the
    "RSS3" string. The machine ID is displayed on the screen menu asking for the
    license key. It always begin with RSS3 and is 16 characters long.

    At 0x08053970, you can see the "license_key" variable being malloc'd for
    1024 bytes and then memset'd to 0.

    At 0x080539de, there is a call to what I call the "gen_1" function, using
    "machine_id" and "license_key" variables. This is how the licenses work. The
    binary generates first a machine ID and from it generates the license key. A
    simple strcmp is used a 0x080539f7.

    Let's go inside gen_1 function. There is a bunch of variables, two functions
    being called and then a loop. The loop is the place where "license_key" is
    being written with dashes between every 4 characters.
    
    At 0x0806a88f, there is a calling function to 0x0806a680. I call this
    function gen_2. It takes a pointer to a local variable, machind_id and the
    strlen of machine_id. Inside is, a bunch a operations are made.

    Still in gen_2, at 0x0806a720, there is a calling function to 0x08069ed0. I
    call this function gen_3 and it takes two variables from gen_2. I call them
    "first_salt" and "second_salt". A lot of bitwise operations are made.

    Let's go back to gen_1. After the call to gen_2, another calling function is
    made at 0x0806a899 to 0x0806a740. A function I call gen_4. The last
    function. It takes the same variable local variable address as for gen_2.
    This function calls gen_2 and gen_3 with some local variables and a string.

    Back to gen_1, the loop writes into "license_key".

    Then it goes back to the main, and strcmp machine_id and license_key.

    I have a lot of errors after exporting the code. A lot of times, the stack
    is smashed. This is why I still cannot make a keygen out of it.

    But I'm still working on it on my very limited free time.

How to change the ISO:
    If you ever download the ISO and want to modify it, this is how you can do
    it.

    Mount the ISO file into a temporary directory.
    sh$ mkdir tmp_iso
    sh$ mount ./rss3.iso temp_iso
    Copy it somewhere else.
    sh$ cp -r tmp_iso iso
    sh$ umount ./tmp_iso
    Extract the initrd.img file
    sh$ cd iso/isolinux
    sh$ mkdir tmp_initrd
    sh$ cd tmp_initrd
    sh$ mv ../initrd.img .
    sh$ cat initrd.img | gzip -d | cpio -i 2>/dev/null
    sh$ rm initrd.img
    The file you are looking for is ./sbin/loader. You can change kinda whatever
    you want. If you want to add some binaries, take them from Red Hat 6.

    To make the new ISO file bootable (considering you are still in
    iso/isolinux/tmp_initrd/)
    sh$ find . | cpio -o --format=newc 2>/dev/null | gzip -9c >../initrd.img
    sh$ cd ../
    sh$ rm -rf tmp_initrd
    sh$ cd ../../
    sh$ mkisofs -o new_rss3.iso -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table iso/
    That's it!

Funfacts:
    Some odd sentences are inside the binary. Odds because of some basic English
    mistakes, such as "We provides a experimental version to you.".

    Also, Google Translate translates the first part of the screen displaying an
    error as "Breast milk".

Now?:
    Ok, it's not a real keygen. But it's a start. I extracted all the
    interesting code (I think, I'm not entirely sure), I just have to make it
    work and publish it.

    Be patient, slipstream.

Requirements:
    * cut
    * gdb
    * grep
    * sed
